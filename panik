
import re #Importing the re module. This is done because we are using regular expressions to tokenize text.

class Main(object): #This is our main class which contains all the methods for modifying the text.

    def clean_text(self): #This method cleans the text in the subtitle files from unneccessary characters.
        self.cleaned = re.sub(r'{.+}{.+}|\||<.+>|[.+]|#',' ',text) #Replaces'{.+}{.+}|\||<.+>|[.+]|#' with space.
        self.cleaned = re.sub(r'"','', self.cleaned) # Removes '"'.

    def make_lower(self): 
        self.lowered_text=[text.lower() for text in self.cleaned] # Converts every character to lowercase.

    def convert_list_to_str(self):#Method that converts list to string (because it's easier to tokenize a string than a list).
        self.string = ''.join(self.lowered_text) 

    def tokenize(self): #Method that tokenizes the text, using a regex. Finds words, numbers, abbreviations and contractions. 
        self.tokenized = re.findall(r'\b[a-z]+\.[a-z]+\.[a-z]+|[a-z]+\.[a-z]+\.|\d+\.\d+|\d+\,\d+|\d+\:\d+|\d+\/\d+|\.{2,}|[a-z]+\'[a-z]+|[$â‚¬]\d+(?:[\.\,]\d+)*|[a-z]+\'|\'[a-z]+|\w+(?:-\w+)*|\S\b', self.string) 

    def find_trigrams(self): #Method that creates trigrams from the tokenized text.
        #Below we are using sliced lists and zip to create the trigrams. 
        self.make_trigrams = list(zip(self.tokenized, self.tokenized[1:], self.tokenized[2:])) 
    
    def counter(self): #This method counts the amount of duplicate trigrams by using list comprehension.
        #Gives us the trigrams in this format: [1, ('this', 'a', 'sicilian')]
        self.counted_trigrams=[[self.make_trigrams.count(x),x] for x in set(self.make_trigrams)]


class Node:
    def __init__(self, initdata):
        self.data = initdata
        self.next = None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data = newdata

    def setNext(self, newnext):
        self.next = newnext

class unorderedList:
    def __init__(self):
        self.head = None

    def isEmpty(self):
        return self.head == None

    def add(self, item):
        temp = Node(item)
        temp.setNext(self.head)
        self.head = temp

    def length(self):
        current = self.head
        count = 0
        while current != None:
            count = count + 1
            current = current.getNext()
        return count

    def search(self, item):
        current = self.head
        found = False
        while current != None and not found:
            if current.getData() == item:
                found = True
                print(found)
            else:
                current = current.getNext()

        return print(found)


    def remove(self, item):
        current = self.head
        previous = None
        found = False
        while not found:
            if current.getData() == item:
                found = True

            else:
                previous = current
                current = current.getNext()

        if previous == None:
            self.head = current.getNext()
        else:
            previous.setNext(current.getNext())

    def PrintTotal(self, node):
        while node:
            print('Total:',node.data)
            node = node.next



def insertionSort(h): #Function that sorts my list
    if h == None:
        return None
    #Make the first node the start of the sorted list.
    sortedList= h
    h=h.next
    sortedList.next= None
    while h != None:
        curr= h
        h=h.next
        if curr.data<sortedList.data:
            #Moves nodes forward
            curr.next= sortedList
            sortedList= curr
        else:
            #Search list for correct position of current.
            search= sortedList
            while search.next!= None and curr.data > search.next.data:
                search= search.next
            #Current goes after search.
            curr.next= search.next
            search.next= curr
    return sortedList


files = ([r'/home/stp14/filtorn/programmering_2/projekt/the_godfather_part_II.sub', #The subtitle files saved to "files".
r'/home/stp14/filtorn/programmering_2/projekt/the_shawshank_redemption.sub'])

dictionary = {} #Creating an empty dictinary which is later going to be filled with trigrams from all of the subtitle files.
linked_list = LinkedList() #Instantiating LinkedList() as "linked_list".

#This loop is the where we call our methods. The loop is necessary so that we can all steps for every element in the list "files".
for element in files: #For each element in the variable "files":
        with open(element,'r', encoding='latin-1') as fin: #Opens each element with latin-1 encoding as fin
                text = fin.read() #Assigns fin.read() to the variable "text".
        main = Main() #Instantiating Main() as "main".
        main.clean_text() #Calling the method clean_text() from the class Main().
        main.make_lower() #Calling the method make_lower() from the class Main()
        main.convert_list_to_str() #Calling the method convert_list_to_str() from the class Main()
        main.tokenize() #Calling the method tokenize() from the class Main()
        main.find_trigrams() #Calling the method find_trigrams() from the class Main() 
        main.counter() #Calling the method counter() from the class Main()

        for trigram in main.make_trigrams: #Loop for every trigram in make_trigrams in the class Main().
            if trigram in dictionary: 
                dictionary[trigram] += 1 #If duplicates are found, increase the int by 1.
            else:
                dictionary[trigram] = 1 #If duplicates are not found, set the int to 1.


result = [[v, k] for k, v in dictionary.items()] #Converting the dictionary to a list (so that it can be added to the linked list).

for trigram in result: #The loop that adds the trigrams into the linked list.
    linked_list.add(trigram) #Adds the trigrams to the linked list by using our add method.
insertionSort(linked_list.head) #Sorts the linked list using insertion sort.
linked_list.Print(linked_list.head) #Prints the linked list
















