__author__ = 'Max&Filip'
# coding: utf-8
import re #Importing the re module. This is done because we are using regular expressions to tokenize text.

class Main(object): #This is our main class which contains all the methods for modifying the text.

    def clean_text(self): #This method cleans the text in the subtitle files from unneccessary characters.
        self.cleaned = re.sub(r'{.+}{.+}|\||<.+>|[.+]|#',' ',text) #Replaces'{.+}{.+}|\||<.+>|[.+]|#' with space.
        self.cleaned = re.sub(r'"','', self.cleaned) # Removes '"'.

    def make_lower(self):
        self.lowered_text=[text.lower() for text in self.cleaned] # Converts every character to lowercase.

    def convert_list_to_str(self):#Method that converts list to string (because it's easier to tokenize a string than a list).
        self.string = ''.join(self.lowered_text)

    def tokenize(self): #Method that tokenizes the text, using a regex. Finds words, numbers, abbreviations and contractions.
        self.tokenized = re.findall(r'\b[a-z]+\.[a-z]+\.[a-z]+|[a-z]+\.[a-z]+\.|\d+\.\d+|\d+\,\d+|\d+\:\d+|\d+\/\d+|\.{2,}|[a-z]+\'[a-z]+|[$â‚¬]\d+(?:[\.\,]\d+)*|[a-z]+\'|\'[a-z]+|\w+(?:-\w+)*|\S\b', self.string)

    def find_trigrams(self): #Method that creates trigrams from the tokenized text.
        #Below we are using sliced lists and zip to create the trigrams.
        self.make_trigrams = list(zip(self.tokenized, self.tokenized[1:], self.tokenized[2:]))

    def counter(self): #This method counts the amount of duplicate trigrams by using list comprehension.
        #Gives us the trigrams in this format: [1, ('this', 'a', 'sicilian')]
        self.counted_trigrams=[[self.make_trigrams.count(x),x] for x in set(self.make_trigrams)]


class Node:
    def __init__(self, initdata):#instance variable that we use to store data
        self.data = initdata #initdata is the data we want to work with.
        self.next = None

    def getData(self):
        return self.data#returns our input data

    def getNext(self):
        return self.next #returns next node

    def setData(self,newdata):#sets data
        self.data = newdata#saves data so we can access it.

    def setNext(self, newnext):
        self.next = newnext#holds next node method, makes it so we can moveforward

class LinkedList:
    def __init__(self):
        self.head = None#sets the first item our list to none, needs to be this in order to be able fill the list.

    def isEmpty(self):#Checks if list is empty
        return self.head == None#Only needs to check head, since head is the first item in the list.

    def add(self, item):#Adds items to our list,
        temp = Node(item)#sets items as an object to Node
        temp.setNext(self.head)#After head comes next item
        self.head = temp#self head gets all the data


    def search(self, item):#To use this search instanced variable name like this, x.search([28, ('is', 'better', 'than')]) It needs to be the whole item.
        current = self.head#starts to check at the beggining of list.
        found = False#Default False.
        while current != None and not found:#Boleean expression regulates that our loop will actually try  to look for our item
            if current.getData() == item:
                found = True#If item is in our list it gets true
                print(found)
            else:
                current = current.getNext()#Checks next item

        return found#returns found, if found is true then it is true that the item is in our list, than


    def remove(self, item):#Remove method if we want to remove a whole item, remember it needs to be x.remove([28, ('is', 'better', 'than')]) to work.
        current = self.head#starts to check at the beggining of list.
        previous = None#used so the remove method can look back.
        found = False
        #This does so that every variable points to a node, the node that has no variable pointed to it gets deleted.
        while not found:#If we have not found it we start to moving forward in the list
            if current.getData() == item:
                found = True

            else:
                previous = current#This moves the node.
                current = current.getNext()

        if previous == None:
            self.head = current.getNext()
        else:
            previous.setNext(current.getNext())

    def Print(self, node):#Print method
        while node:
            print('Total:',node.data)#gets the data from our nodes
            node = node.next#Then goes to the next node. This way we are priting the entire list.



def insertionSort(file): #Function that sorts our list
    if file == None:#Checks if our list is empty before sorting it
        return None
    #Make the first node the start of the sorted list.
    sortedList= file
    file=file.next
    sortedList.next= None
    while file != None:#If not empty
        curr= file#curr points to node.
        file=file.next#makes file point to next node
        if curr.data<sortedList.data:
            #Goes through our list by moving nodes forward (sorting this way)
            curr.next= sortedList
            sortedList= curr
        else:
            #Finds the best place for curr (current) in order of our list.
            search= sortedList
            while search.next!= None and curr.data > search.next.data:
                search= search.next
            #Then Current goes after search, this way we are moving nodes and placing them where they need to be
            curr.next= search.next
            search.next= curr
    return sortedList


#Files is a variable where we store the files we want to open in a list. 
files = ([r'/home/yourusername/filepath/filename.sub',#how to open files on linux machines
        'C:\\Users\\Yourusername\\filepath\\filename.sub']) #How to open files on windows machines

dictionary = {} #Creating an empty dictinary which is later going to be filled with trigrams from all of the subtitle files.
linked_list = LinkedList() #Instantiating LinkedList() as "linked_list".

#This loop is the where we call our methods. The loop is necessary so that we can all steps for every element in the list "files".
for element in files: #For each element in the variable "files":
        with open(element,'r', encoding='latin-1') as fin: #Opens each element with latin-1 encoding as fin
                text = fin.read() #Assigns fin.read() to the variable "text".
        main = Main() #Instantiating Main() as "main".
        main.clean_text() #Calling the method clean_text() from the class Main().
        main.make_lower() #Calling the method make_lower() from the class Main()
        main.convert_list_to_str() #Calling the method convert_list_to_str() from the class Main()
        main.tokenize() #Calling the method tokenize() from the class Main()
        main.find_trigrams() #Calling the method find_trigrams() from the class Main()
        main.counter() #Calling the method counter() from the class Main()

        for trigram in main.make_trigrams: #Loop for every trigram in make_trigrams in the class Main().
            if trigram in dictionary:
                dictionary[trigram] += 1 #If duplicates are found, increase the int by 1.
            else:
                dictionary[trigram] = 1 #If duplicates are not found, set the int to 1.


result = [[v, k] for k, v in dictionary.items()] #Converting the dictionary to a list (so that it can be added to the linked list).

for trigram in result: #The loop that adds the trigrams into the linked list.
    result = map(int, result) #Converts evert trigram to a class object (so that we can remove and search for them)
    linked_list.add(trigram) #Adds the trigrams to the linked list by using our add method.

insertionSort(linked_list.head) #Sorts the linked list using insertion sort.
linked_list.Print(linked_list.head) #Prints the linked list

